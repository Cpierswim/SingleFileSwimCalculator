<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Swimmer Client</title>
    <link
      href="https://fonts.googleapis.com/css?family=Noto Sans Mono"
      rel="stylesheet"
    />
    <style>
      #Main_Clock {
        color: greenyellow;
        font-size: 25.5vw;
        font-weight: 600;
        font-family: "Noto Sans Mono", "Courier New", Courier, monospace;
      }

      #container {
        width: 100vw;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .black_background {
        background-color: black;
      }

      #connection_status {
        position: fixed;
        bottom: 3px;
        right: 3px;
        color: white;
        font-weight: bolder;
      }
      .disconnected_from_coach {
        color: red;
      }
    </style>
  </head>
  <body onbeforeunload="return closeWebSocket()">
    <div class="container" id="container">
      <button type="button" onclick="startApp(0)" id="fullscreenbutton">
        Cick Me To Just Start Clock
      </button>
      <button type="button" onclick="startApp(1)" id="withconnectionbutton">
        Click Me To Start With Connection
      </button>
    </div>

    <script>
      const SKIP_FULLSCREEN = 0;
      let socket = undefined;
      let clock;
      let time_delta;
      let additional_time_delta = 0;
      let wakeLock = null;

      function closeWebSocket() {
        socket.close();
      }

      async function startApp(button_clicked) {
        if (button_clicked === 0) {
          setupClock();
        } else {
          removeInitialButtons();

          let room_code_label = document.createElement("label");
          room_code_label.htmlFor = "room_code_input";
          room_code_label.innerText = "Room Code: ";
          room_code_label.id = "room_code_label";

          let room_code_input = document.createElement("input");
          room_code_input.id = "room_code_input";

          let lane_selector = document.createElement("input");
          lane_selector.type = "number";
          lane_selector.id = "lane_selector";
          lane_selector.min = 1;
          lane_selector.max = 10;
          lane_selector.value = 1;

          let lane_label = document.createElement("label");
          lane_label.htmlFor = "lane_selector";
          lane_label.innerText = "Select your lane: ";
          lane_label.id = "lane_label";

          let connect_button = document.createElement("button");
          connect_button.id = "connect_button";
          connect_button.type = "button";
          connect_button.innerText = "Connect";
          connect_button.addEventListener("click", ConnectToCoach);

          let connection_messages_display = document.createElement("p");
          connection_messages_display.id = "connection_messages_display";

          let container = document.getElementById("container");

          container.appendChild(room_code_label);
          container.appendChild(room_code_input);
          container.appendChild(lane_label);
          container.appendChild(lane_selector);
          container.appendChild(connect_button);
          container.appendChild(connection_messages_display);
        }
      }

      async function setupClock() {
        socket = new WebSocket(
          "wss://mjim68pp6h.execute-api.us-east-2.amazonaws.com/production/"
        );
        socket.onopen = (event) => {
          newGetTimeDelta();
        };
        socket.onmessage = (event) => {
          let data = JSON.parse(event.data);
          if (data?.message == "Internal server error")
            _handleInternalServerError();
          else {
            if (data.type == "timestamp") {
              dealWithTimeStamp(data);
            }
          }
        };

        var main_screen = document.getElementById("container");
        requestFullScreen(main_screen);

        requestScreenLock();

        //Update the display to the clock - will need to refactor later
        removeInitialButtons();

        clock = document.createElement("p");
        clock.id = "Main_Clock";
        clock.className = "Main_Clock";
        clock.innerText = "00:00";
        main_screen.classList.add("black_background");
        main_screen.appendChild(clock);

        //start the clock
        //await getTimeDelta();
        newGetTimeDelta();
        //StartClock();

        setInterval(newSetClock, 10);
      }

      function removeInitialButtons() {
        const container = document.getElementById("container");
        while (container.firstChild) {
          container.removeChild(container.firstChild);
        }
      }

      function newGetTimeDelta() {
        if (socket.readyState == 1) {
          let data = { action: "getTime", initial_time: Date.now() };
          socket.send(JSON.stringify(data));
        }
      }

      function _handleInternalServerError() {}

      function dealWithTimeStamp(data) {
        let current_time = Date.now();
        let trip_time = current_time - data.initial_time;
        time_delta = data.timestamp - current_time + Math.floor(trip_time / 2);
      }

      function requestFullScreen(div_to_fullscreen) {
        //request Full Screen
        if (typeof SKIP_FULLSCREEN === "undefined") return;
        if (SKIP_FULLSCREEN == 1) return;

        if (div_to_fullscreen.requestFullscreen) {
          div_to_fullscreen.requestFullscreen();
        } else if (div_to_fullscreen.webkitRequestFullscreen) {
          /* Safari */
          div_to_fullscreen.webkitRequestFullscreen();
        } else if (div_to_fullscreen.msRequestFullscreen) {
          /* IE11 */
          div_to_fullscreen.msRequestFullscreen();
        }
      }

      function newSetClock() {
        if (isNaN(time_delta)) {
          clock.innerText = "00:00";
          return "";
        }
        let curr = Date.now();
        curr += time_delta + additional_time_delta;
        let display_time = new Date(curr);
        clock.innerText = `${checkTime(display_time.getMinutes())}:${checkTime(
          display_time.getSeconds()
        )}`;
      }

      function ConnectToCoach() {
        let connection_messages_display = document.getElementById(
          "connection_messages_display"
        );
        connection_messages_display.innerHTML =
          "Attempting to connect to server...";
        socket = new WebSocket(
          "wss://mjim68pp6h.execute-api.us-east-2.amazonaws.com/production/"
        );

        socket.onopen = (event) => {
          newGetTimeDelta();
          connection_messages_display.innerHTML +=
            "<br />Connection Established.";
          let set_connection_type_data = {
            action: "setConnectionType",
            type: "swimmer",
          };
          socket.send(JSON.stringify(set_connection_type_data));
          setInterval(newGetTimeDelta, 10000);

          connection_messages_display.innerHTML +=
            "<br />Attempting to connect to room";
          let room_code_input = document.getElementById("room_code_input");
          let roomKey = room_code_input.value;
          let lane_selector = document.getElementById("lane_selector");
          let lane = lane_selector.value;
          let data = {
            action: "laneConnect",
            LaneNumber: lane,
            roomKey: roomKey,
          };
          socket.send(JSON.stringify(data));
        };

        socket.onerror = (error) => {
          connection_messages_display.innerHTML += "<br />Error in connection";
        };

        socket.onmessage = (event) => {
          let data = JSON.parse(event.data);
          if (data?.message == "Internal server error")
            _handleInternalServerError();
          else {
            switch (data.type) {
              case "LaneConnect":
                connection_messages_display.innerHTML +=
                  "<br />Connected to Room";
                _processLaneConnect(data.laneNumber);
                break;
              case "error":
                _processError(data);
                break;
              case "resetClock":
                //syncClock(data);
                newSyncClock(data);
                break;
              case "timestamp":
                dealWithTimeStamp(data);
                break;
            }
          }
        };

        socket.onclose = (event) => {
          let connection_status = document.getElementById("connection_status");
          connection_status.innerText = "Disconnected...";
          connection_status.classList.add("disconnected_from_coach");
        };
      }

      function _processLaneConnect(laneNumber) {
        setupClock();

        let connection_status_div = document.createElement("div");
        connection_status_div.id = "connection_status";
        connection_status_div.innerText = "Connected to Coach";
        let temp = document.getElementById("container");
        temp.appendChild(connection_status_div);
      }

      function _processError(data) {
        let connection_messages_display = document.getElementById(
          "connection_messages_display"
        );
        connection_messages_display.innerHTML += "<br />Error: " + data.message;
      }

      function newSyncClock(data) {
        additional_time_delta = data.additional_time_delta;
      }

      function checkTime(i) {
        if (i < 10) return `0${i}`;
        return i + "";
      }

      async function requestScreenLock() {
        if ("wakeLock" in navigator) {
          try {
            wakeLock = await awaitnavigator.wakeLock.request("screen");
            document.addEventListener("visibilitychange", async () => {
              if (wakeLock !== null && document.visibilityState === "visible") {
                wakeLock = await navigator.wakeLock.request("screen");
              }
            });
          } catch (err) {
            //don't need to do anything if it doesn't work
          }
        }
      }
    </script>
  </body>
</html>
