<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Swimmer Client</title>
    <link
      href="https://fonts.googleapis.com/css?family=Noto Sans Mono"
      rel="stylesheet"
    />
    <style>
      #Main_Clock {
        color: greenyellow;
        font-size: 25.5vw;
        font-weight: 600;
        font-family: "Noto Sans Mono", "Courier New", Courier, monospace;
      }

      #container {
        width: 100vw;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .black_background {
        background-color: black;
      }

      #connection_status {
        position: fixed;
        bottom: 3px;
        right: 3px;
        color: white;
        font-weight: bolder;
      }
    </style>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.2.0/dist/peerjs.min.js"></script>
  </head>
  <body onbeforeunload="return closeWebSocket()">
    <div class="container" id="container">
      <button type="button" onclick="startApp(0)" id="fullscreenbutton">
        Cick Me To Just Start Clock
      </button>
      <button type="button" onclick="startApp(1)" id="withconnectionbutton">
        Click Me To Start With Connection
      </button>
    </div>

    <script>
      const SKIP_FULLSCREEN = 1;
      const BASE_URL = "http://localhost:3000/";
      const PEER_BASE = "3SLDFGPSOGHAA";
      const PEER_TYPE = "LANE";
      const COACH_ID = PEER_BASE + "-" + "COACH";
      let ID = PEER_BASE + "-" + PEER_TYPE;
      let CONNECTED_TO_COACH = false;

      let clock;
      let time_delta;
      let clock_promise;

      let socket = undefined;

      async function getTimeDelta() {
        const start_millis = Date.now();
        const response = await axios.get(
          `https://worldtimeapi.org/api/timezone/America/Detroit`
        );
        const end_millis = Date.now();
        const data = response.data;

        const trip_time = end_millis - start_millis;
        const server_millis = parseInt(
          data["unixtime"] +
            data["utc_datetime"].split(".")[1].split("+")[0].substring(0, 3)
        );

        time_delta = server_millis - start_millis + Math.floor(trip_time / 2);
      }

      function newGetTimeDelta() {
        let data = { action: "getTime", initial_time: Date.now() };
        socket.send(JSON.stringify(data));
      }

      function dealWithTimeStamp(data) {
        let current_time = Date.now();
        let trip_time = current_time - data.initial_time;
        time_delta = data.timestamp - current_time + Math.floor(trip_time / 2);
      }

      function SetClock() {
        var start = Date.now() + time_delta;
        const date = new Date(start);
        var minutes = date.getMinutes();
        var seconds = date.getSeconds();
        const checkTime = (i) => {
          if (i < 10) return `0${i}`;
          return i + "";
        };
        const minute = checkTime(minutes);
        const second = checkTime(seconds);
        clock.innerText = `${minute}:${second}`;
      }

      function requestFullScreen(div_to_fullscreen) {
        //request Full Screen
        if (typeof SKIP_FULLSCREEN === "undefined") return;
        if (SKIP_FULLSCREEN == 1) return;

        if (div_to_fullscreen.requestFullscreen) {
          div_to_fullscreen.requestFullscreen();
        } else if (div_to_fullscreen.webkitRequestFullscreen) {
          /* Safari */
          div_to_fullscreen.webkitRequestFullscreen();
        } else if (div_to_fullscreen.msRequestFullscreen) {
          /* IE11 */
          div_to_fullscreen.msRequestFullscreen();
        }
      }

      async function startApp(button_clicked) {
        if (button_clicked === 0) {
          setupClock();
        } else {
          removeInitialButtons();

          let room_code_label = document.createElement("label");
          room_code_label.htmlFor = "room_code_input";
          room_code_label.innerText = "Room Code: ";
          room_code_label.id = "room_code_label";

          let room_code_input = document.createElement("input");
          room_code_input.id = "room_code_input";

          let lane_selector = document.createElement("input");
          lane_selector.type = "number";
          lane_selector.id = "lane_selector";
          lane_selector.min = 1;
          lane_selector.max = 10;
          lane_selector.value = 1;

          let lane_label = document.createElement("label");
          lane_label.htmlFor = "lane_selector";
          lane_label.innerText = "Select your lane: ";
          lane_label.id = "lane_label";

          let connect_button = document.createElement("button");
          connect_button.id = "connect_button";
          connect_button.type = "button";
          connect_button.innerText = "Connect";
          connect_button.addEventListener("click", ConnectToCoach);

          let connection_messages_display = document.createElement("p");
          connection_messages_display.id = "connection_messages_display";

          let container = document.getElementById("container");

          container.appendChild(room_code_label);
          container.appendChild(room_code_input);
          container.appendChild(lane_label);
          container.appendChild(lane_selector);
          container.appendChild(connect_button);
          container.appendChild(connection_messages_display);
        }
      }

      async function setupClock() {
        var main_screen = document.getElementById("container");
        requestFullScreen(main_screen);

        //Update the display to the clock - will need to refactor later
        removeInitialButtons();

        clock = document.createElement("p");
        clock.id = "Main_Clock";
        clock.className = "Main_Clock";
        clock.innerText = "00:00";
        main_screen.classList.add("black_background");
        main_screen.appendChild(clock);

        //start the clock
        //await getTimeDelta();
        newGetTimeDelta();
        //StartClock();
        newStartClock();
      }

      function newSetClock() {
        if (isNaN(time_delta)) {
          clock.innerText = "00:00";
          return "";
        }
        let curr = Date.now();
        curr += time_delta;
        let display_time = new Date(curr);
        clock.innerText = `${checkTime(display_time.getMinutes())}:${checkTime(
          display_time.getSeconds()
        )}`;
      }

      function newStartClock() {
        setInterval(newSetClock, 10);
      }

      function removeInitialButtons() {
        const container = document.getElementById("container");
        while (container.firstChild) {
          container.removeChild(container.firstChild);
        }
      }

      function ResetClock() {
        SetClock();
      }

      function SetClockToTickEverySecond() {
        SetClock();
        clock_promise = setInterval(ResetClock, 1000);
      }

      async function StartClock() {
        SetClock();
        var start = Date.now() + time_delta;
        const date = new Date(start);
        var delay = 1000 - date.getMilliseconds();
        setTimeout(SetClockToTickEverySecond, delay);
      }

      function keepAlive() {
        let data = { action: "keepAlive" };
        socket.send(JSON.stringify(data));
      }

      function ConnectToCoach() {
        let connection_messages_display = document.getElementById(
          "connection_messages_display"
        );
        connection_messages_display.innerHTML =
          "Attempting to connect to server...";
        socket = new WebSocket(
          "wss://mjim68pp6h.execute-api.us-east-2.amazonaws.com/production/"
        );

        socket.onopen = (event) => {
          connection_messages_display.innerHTML +=
            "<br />Connection Established.";
          let set_connection_type_data = {
            action: "setConnectionType",
            type: "swimmer",
          };
          socket.send(JSON.stringify(set_connection_type_data));
          setInterval(newGetTimeDelta, 120000);

          connection_messages_display.innerHTML +=
            "<br />Attempting to connect to room";
          let room_code_input = document.getElementById("room_code_input");
          let roomKey = room_code_input.value;
          let lane_selector = document.getElementById("lane_selector");
          let lane = lane_selector.value;
          let data = {
            action: "laneConnect",
            LaneNumber: lane,
            roomKey: roomKey,
          };
          socket.send(JSON.stringify(data));
        };

        socket.onerror = (error) => {
          connection_messages_display.innerHTML += "<br />Error in connection";
        };

        socket.onmessage = (event) => {
          let data = JSON.parse(event.data);
          if (data?.message == "Internal server error")
            _handleInternalServerError();
          else {
            switch (data.type) {
              case "LaneConnect":
                connection_messages_display.innerHTML +=
                  "<br />Connected to Room";
                _processLaneConnect(data.laneNumber);
                break;
              case "error":
                _processError(data);
                break;
              case "resetClock":
                //syncClock(data);
                newSyncClock(data);
                break;
              case "timestamp":
                dealWithTimeStamp(data);
                break;
            }
          }
        };

        socket.onclose = (event) => {};
      }

      function _handleInternalServerError() {}

      function _processLaneConnect(laneNumber) {
        setupClock();

        let connection_status_div = document.createElement("div");
        connection_status_div.id = "connection_status";
        connection_status_div.innerText = "Connected to Coach";
        let temp = document.getElementById("container");
        temp.appendChild(connection_status_div);
      }

      function _processError(data) {
        let connection_messages_display = document.getElementById(
          "connection_messages_display"
        );
        connection_messages_display.innerHTML += "<br />Error: " + data.message;
      }
      function _connect() {
        conn = peer.connect(COACH_ID, { serialization: "json" });

        conn.on("open", function () {
          //connection with coach opened

          conn.on("data", function (data) {
            if ("error" in data) {
              _errorConnecting({ message: "That lane is taken" });
              conn.close();
            }

            if ("connection_sucess" in data) {
              setupClock();

              let connection_status_div = document.createElement("div");
              connection_status_div.id = "connection_status";
              connection_status_div.innerText = "Connected to Coach";
              let temp = document.getElementById("container");
              temp.appendChild(connection_status_div);
            }
          });
        });
      }

      function _errorConnecting(err) {
        let p = document.createElement("p");
        if (err.message == "Lost connection to server.") {
          p.innerText = "Error. ";
          console.log("Retry");
        } else if (err.message.includes("is taken")) {
          console.log("Lane taken");
          p.innerText = "That lane is taken";
        }

        p.id = "connection_error";
        let temp = document.getElementById("container");
        temp.appendChild(p);
      }

      function disconnect() {
        peer.destroy();
      }

      function closeWebSocket() {
        example_socket.close();
      }

      function syncClock(data) {
        clearInterval(clock_promise);
        const checkTime = (i) => {
          if (i < 10) return `0${i}`;
          return i + "";
        };

        let minutes = checkTime(data.minutes);
        let seconds = checkTime(data.seconds);

        clock.innerText = minutes + ":" + seconds;
        clock_promise = setInterval(tempResetClock, 1000);
      }

      function tempResetClock() {
        let clock_text = clock.innerText;
        let clock_text_list = clock_text.split(":");
        let minutes = parseInt(clock_text_list[0]);
        let seconds = parseInt(clock_text_list[1]);
        seconds++;
        if (seconds >= 60) {
          minutes++;
          seconds = 0;
        }
        if (minutes >= 60) minutes = 0;
        let new_text = checkTime(minutes) + ":" + checkTime(seconds);
        clock.innerText = new_text;
      }

      function checkTime(i) {
        if (i < 10) return `0${i}`;
        return i + "";
      }

      function newSyncClock(data) {
        let now = Date.now();
        let adjusted_time = new Date(now);

        adjusted_time.setMinutes(data.minutes);
        adjusted_time.setSeconds(data.seconds);
        adjusted_time.setMilliseconds(0);
        time_delta = 0 - (now - adjusted_time.getTime());
      }
    </script>
  </body>
</html>
