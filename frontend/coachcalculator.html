<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Coach Server</title>
    <link
      href="https://fonts.googleapis.com/css?family=Noto Sans Mono"
      rel="stylesheet"
    />
    <style>
      #Main_Clock {
        color: greenyellow;

        font-weight: 600;
        font-family: "Noto Sans Mono", "Courier New", Courier, monospace;
        width: 80vw;
      }

      #Coach_Controls {
        width: 20vw;
        border-left: 8px solid red;
      }

      #container {
        width: 100vw;
        height: 100vh;
        display: block;
      }

      .black_background {
        background-color: black;
      }

      #connections_screen {
        width: 100%;
      }

      #connection_status {
        font-size: large;
        color: white;
      }
      .pfill {
        margin: 0px;
        margin-top: -4px;
      }
      .lane {
        width: 50px;
        height: 50px;
        border-style: solid;
        border-width: 2px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 50px;
        font-weight: 800;
        font-family: "Bowlby One SC", cursive;
      }
      .connectedLane {
        border-color: aqua;
        background-color: aquamarine;
      }
      .disconnected {
        border-color: blueviolet;
        background-color: brown;
        color: beige;
      }
      #upper_div {
        width: 100%;
        height: 20%;
      }
      #lower_div {
        height: 80%;
        width: 100%;
        border-color: white;
        border-bottom: 3px;
        border-style: solid;
      }
      #room_code {
        float: left;
        width: 15%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5vw;
        color: white;
        font-weight: 600;
        text-align: center;
      }
      #clock_div {
        float: left;
        width: 45%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10vw;
        color: greenyellow;
        font-weight: 600;
        font-family: "Courier New", Courier, monospace;
      }
      #connections_div {
        float: left;
        width: 40%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
      }
    </style>
  </head>
  <body onbeforeunload="return closeWebSocket()">
    <div class="container" id="container">
      <button type="button" onclick="startApp()" id="fullscreenbutton">
        Cick Me To Start App
      </button>
    </div>

    <script>
      const SKIP_FULLSCREEN = 1;

      let socket = undefined;
      const LANES = {};
      let clock;
      let time_delta;
      let additional_time_delta = 0;
      let roomKey;

      function closeWebSocket() {
        socket.close();
      }

      async function startApp() {
        var main_screen = document.getElementById("container");
        main_screen.classList.add("black_background");
        requestFullScreen(main_screen);

        requestScreenLock();

        //Update the display to the clock - will need to refactor later
        const full_screen_button = document.getElementById("fullscreenbutton");
        full_screen_button.remove();

        const upper_div = document.createElement("div");
        upper_div.id = "upper_div";
        main_screen.appendChild(upper_div);

        const lower_div = document.createElement("div");
        lower_div.id = "lower_div";
        main_screen.appendChild(lower_div);

        const room_code_div = document.createElement("div");
        room_code_div.id = "room_code";
        upper_div.appendChild(room_code_div);
        const room_code_p = document.createElement("p");
        room_code_p.id = "room_code_text";
        room_code_p.innerHTML = "Room Code: <br />---";
        room_code_div.appendChild(room_code_p);

        const clock_div = document.createElement("div");
        clock_div.id = "clock_div";
        upper_div.appendChild(clock_div);
        const clock_p = document.createElement("p");
        clock_p.id = "clock_text";
        clock_p.innerHTML = "00:00";
        clock_div.appendChild(clock_p);
        const connections_div = document.createElement("div");
        connections_div.id = "connections_div";
        connections_div.innerText = "Connecting to server...";
        upper_div.appendChild(connections_div);

        clock = clock_p;

        const sync_clock_button = document.createElement("button");
        sync_clock_button.id = "sync_clock_button";
        sync_clock_button.innerText = "Sync Clocks";
        sync_clock_button.addEventListener("click", syncClocks);

        const set_to_zero_button = document.createElement("button");
        set_to_zero_button.id = "set_to_zero_button";
        set_to_zero_button.innerText = "Set to :00";
        set_to_zero_button.addEventListener("click", setToZero);

        const add_one_minute_button = document.createElement("button");
        add_one_minute_button.id = "add_one_minute_button";
        add_one_minute_button.innerText = "Add 1 min";
        add_one_minute_button.addEventListener("click", addOneMinute);

        const subtract_one_minute_button = document.createElement("button");
        subtract_one_minute_button.id = "subtract_one_minute_button";
        subtract_one_minute_button.innerText = "Sub 1 min";
        subtract_one_minute_button.addEventListener("click", subtractOneMinute);

        lower_div.appendChild(set_to_zero_button);
        lower_div.appendChild(add_one_minute_button);
        lower_div.appendChild(subtract_one_minute_button);
        lower_div.appendChild(sync_clock_button);

        //start the clock
        //await getTimeDelta();

        //StartClock();
        setInterval(newSetClock, 10);
        OpenForConnections();
      }

      function newSetClock() {
        if (isNaN(time_delta)) {
          clock.innerText = "00:00";
          return "";
        }
        let curr = Date.now();
        curr += time_delta + additional_time_delta;
        let display_time = new Date(curr);
        clock.innerText = `${checkTime(display_time.getMinutes())}:${checkTime(
          display_time.getSeconds()
        )}`;
      }

      function requestFullScreen(div_to_fullscreen) {
        //request Full Screen
        if (typeof SKIP_FULLSCREEN === "undefined") return;
        if (SKIP_FULLSCREEN == 1) return;

        if (div_to_fullscreen.requestFullscreen) {
          div_to_fullscreen.requestFullscreen();
        } else if (div_to_fullscreen.webkitRequestFullscreen) {
          /* Safari */
          div_to_fullscreen.webkitRequestFullscreen();
        } else if (div_to_fullscreen.msRequestFullscreen) {
          /* IE11 */
          div_to_fullscreen.msRequestFullscreen();
        }
      }

      function OpenForConnections() {
        socket = new WebSocket(
          "wss://mjim68pp6h.execute-api.us-east-2.amazonaws.com/production/"
        );

        socket.onopen = (event) => {
          newGetTimeDelta();
          let connections_div = document.getElementById("connections_div");
          connections_div.innerText =
            "Sever connection established. Setting as coach...";
          let set_connection_type_data = {
            action: "setConnectionType",
            type: "coach",
          };
          socket.send(JSON.stringify(set_connection_type_data));
          connections_div.innerText = "Creating room...";
          let data = { action: "createRoom" };
          socket.send(JSON.stringify(data));

          setInterval(newGetTimeDelta, 120000);
        };

        socket.onerror = (error) => {
          let connections_div = document.getElementById("connections_div");
          connections_div.innerHTML = "Connection Error";
        };

        socket.onmessage = (event) => {
          let data = JSON.parse(event.data);
          if (data?.message == "Internal server error")
            _processServerError(event.data);
          else {
            if (data.type) {
              switch (data.type) {
                case "RoomCreated":
                  _processRoomCreation(data.data);
                  break;
                case "LaneConnect":
                  _processLaneConnection(data.laneNumber);
                  break;
                case "LaneDisconnect":
                  _processLaneDisconnect(data.laneNumber);
                  break;
                case "resetClock":
                  //syncClock(data);
                  newSyncClock(data);
                  break;
                case "timestamp":
                  dealWithTimeStamp(data);
                  break;
              }
            }
          }
        };
      }

      function newGetTimeDelta() {
        let data = { action: "getTime", initial_time: Date.now() };
        socket.send(JSON.stringify(data));
      }

      function _processServerError(data) {}

      function _processRoomCreation(data) {
        let room_code_text = document.getElementById("room_code_text");
        room_code_text.innerHTML = "Room Code<br />" + data.room_key;
        roomKey = data.room_key;
        let connections_div = document.getElementById("connections_div");
        connections_div.innerText = "Waiting for lanes to connect.";
      }

      function _processLaneConnection(laneNumber) {
        let lane = parseInt(laneNumber);
        LANES[lane] = true;
        UpdateLaneConnections();
      }

      function _processLaneDisconnect(laneNumber) {
        let lane = parseInt(laneNumber);
        LANES[lane] = false;
        UpdateLaneConnections();
      }

      function newSyncClock(data) {
        let now = Date.now();
        let adjusted_time = new Date(now);

        adjusted_time.setMinutes(data.minutes);
        adjusted_time.setSeconds(data.seconds);
        adjusted_time.setMilliseconds(0);
        time_delta = 0 - (now - adjusted_time.getTime());
      }

      function dealWithTimeStamp(data) {
        let current_time = Date.now();
        let trip_time = current_time - data.initial_time;
        time_delta = data.timestamp - current_time + Math.floor(trip_time / 2);
      }

      function UpdateLaneConnections() {
        let keys = Object.keys(LANES);
        let connections_screen = document.getElementById("connections_div");
        while (connections_screen.firstChild) {
          connections_screen.removeChild(connections_screen.firstChild);
        }

        keys.sort((a, b) => a - b);

        keys.forEach((key) => {
          let lane = key;

          if (LANES[lane]) {
            connections_screen.appendChild(_getNewLaneButton(lane));
          } else {
            connections_screen.appendChild(_getNewDisConnectedLaneButton(lane));
          }
        });
      }

      function _getNewLaneButton(lane_number) {
        let lane_div = document.createElement("div");
        let lane_p = document.createElement("p");

        lane_p.innerText = lane_number;
        lane_p.classList.add("pfill");
        lane_div.appendChild(lane_p);
        lane_div.classList.add("connectedLane");
        lane_div.classList.add("lane");
        lane_div.id = "lane_" + lane_number;
        return lane_div;
      }

      function _getNewDisConnectedLaneButton(lane_number) {
        let lane_div = document.createElement("div");
        let lane_p = document.createElement("p");

        lane_p.innerText = lane_number;
        lane_p.classList.add("pfill");
        lane_div.appendChild(lane_p);
        lane_div.classList.add("disconnected");
        lane_div.classList.add("lane");
        lane_div.id = "lane_" + lane_number;
        return lane_div;
      }

      function checkTime(i) {
        if (i < 10) return `0${i}`;
        return i + "";
      }

      async function requestScreenLock() {
        if ("wakeLock" in navigator) {
          try {
            wakeLock = await awaitnavigator.wakeLock.request("screen");
            document.addEventListener("visibilitychange", async () => {
              if (wakeLock !== null && document.visibilityState === "visible") {
                wakeLock = await navigator.wakeLock.request("screen");
              }
            });
          } catch (err) {
            //don't need to do anything if it doesn't work
          }
        }
      }

      function setToZero() {
        let temp = Date.now();
        //debugger;

        let split_clock_text = clock.innerText.split(":");
        let minutes = parseInt(split_clock_text[0]);
        let seconds = parseInt(split_clock_text[1]);

        let running_time = new Date(temp + time_delta);
        let new_time = new Date(running_time);
        new_time.setMinutes(minutes);
        new_time.setSeconds(0);
        new_time.setMilliseconds(0);

        let diff = new_time.getTime() - running_time.getTime();
        sendSyncClocksCommand(diff);
        additional_time_delta = diff;
      }

      function sendSyncClocksCommand(diff) {
        let data = {
          action: "syncClocks",
          additional_time_delta: diff,
          roomKey: roomKey,
        };

        socket.send(JSON.stringify(data));
      }

      function addOneMinute() {
        additional_time_delta += 60000;
        sendSyncClocksCommand(additional_time_delta);
      }

      function subtractOneMinute() {
        additional_time_delta -= 60000;
        sendSyncClocksCommand(additional_time_delta);
      }

      function syncClocks() {
        sendSyncClocksCommand(additional_time_delta);
      }
    </script>
  </body>
</html>
