<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Coach Server</title>
    <link
      href="https://fonts.googleapis.com/css?family=Noto Sans Mono"
      rel="stylesheet"
    />
    <style>
      #Main_Clock {
        color: greenyellow;
        font-size: 25.5vw;
        font-weight: 600;
        font-family: "Noto Sans Mono", "Courier New", Courier, monospace;
        width: 80vw;
      }

      #Coach_Controls {
        width: 20vw;
        height: 100vh;
        border-left: 8px solid red;
      }

      #container {
        width: 100vw;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-wrap: nowrap;
      }

      .black_background {
        background-color: black;
      }

      #connections_screen {
        width: 100%;
      }

      #connection_status {
        font-size: large;
        color: white;
      }
      .pfill {
        margin: 0px;
        margin-top: -4px;
      }
      .lane {
        width: 50px;
        height: 50px;
        border-style: solid;
        border-width: 2px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 50px;
        font-weight: 800;
        font-family: "Bowlby One SC", cursive;
      }
      .connectedLane {
        border-color: aqua;
        background-color: aquamarine;
      }
      .disconnected {
        border-color: blueviolet;
        background-color: brown;
        color: beige;
      }
    </style>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.2.0/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/dropbox/dist/Dropbox-sdk.min.js"></script>
  </head>
  <body>
    <div class="container" id="container">
      <button type="button" onclick="startApp()" id="fullscreenbutton">
        Cick Me To Start App
      </button>
    </div>

    <script>
      const BASE_URL = "http://localhost:3000/";
      const PEER_BASE = "3SLDFGPSOGHAA";
      const PEER_TYPE = "COACH";
      const LANE_TYPE = "LANE";
      let ID = PEER_BASE + "-" + PEER_TYPE;
      const LANES = {};
      const SKIP_FULLSCREEN = 1;

      var clock;
      var time_delta;

      async function getTimeDelta() {
        const start_millis = Date.now();
        const response = await axios.get(
          `https://worldtimeapi.org/api/timezone/America/Detroit`
        );
        const end_millis = Date.now();
        const data = response.data;

        const trip_time = end_millis - start_millis;
        const server_millis = parseInt(
          data["unixtime"] +
            data["utc_datetime"].split(".")[1].split("+")[0].substring(0, 3)
        );

        time_delta = server_millis - start_millis - Math.floor(trip_time / 2);
      }

      function SetClock() {
        var start = Date.now() + time_delta;
        const date = new Date(start);
        var minutes = date.getMinutes();
        var seconds = date.getSeconds();
        const checkTime = (i) => {
          if (i < 10) return `0${i}`;
          return i + "";
        };
        const minute = checkTime(minutes);
        const second = checkTime(seconds);
        clock.innerText = `${minute}:${second}`;
      }

      function requestFullScreen(div_to_fullscreen) {
        //request Full Screen
        if (typeof SKIP_FULLSCREEN === "undefined") return;
        if (SKIP_FULLSCREEN == 1) return;

        if (div_to_fullscreen.requestFullscreen) {
          div_to_fullscreen.requestFullscreen();
        } else if (div_to_fullscreen.webkitRequestFullscreen) {
          /* Safari */
          div_to_fullscreen.webkitRequestFullscreen();
        } else if (div_to_fullscreen.msRequestFullscreen) {
          /* IE11 */
          div_to_fullscreen.msRequestFullscreen();
        }
      }

      async function startApp() {
        var main_screen = document.getElementById("container");
        requestFullScreen(main_screen);

        //Update the display to the clock - will need to refactor later
        const full_screen_button = document.getElementById("fullscreenbutton");
        full_screen_button.remove();
        clock = document.createElement("p");
        clock.id = "Main_Clock";
        clock.className = "Main_Clock";
        clock.innerText = "00:00";
        main_screen.classList.add("black_background");
        main_screen.appendChild(clock);

        //add the coach controls
        const coach_control = document.createElement("div");
        coach_control.id = "Coach_Controls";
        main_screen.appendChild(coach_control);

        //add the connections screen to the coach controls
        const connections_screen = document.createElement("div");
        connections_screen.id = "connections_screen";
        coach_control.appendChild(connections_screen);

        //add the connecting string
        const connection_p = document.createElement("p");
        connection_p.innerText = "Attempting to open for connections...";
        connection_p.id = "connection_status";
        connections_screen.appendChild(connection_p);

        //start the clock
        await getTimeDelta();
        StartClock();
        OpenForConnections();
      }

      function ResetClock() {
        SetClock();
      }

      function SetClockToTickEverySecond() {
        SetClock();
        setInterval(ResetClock, 1000);
      }

      async function StartClock() {
        SetClock();
        var start = Date.now() + time_delta;
        const date = new Date(start);
        var delay = 1000 - date.getMilliseconds();
        setTimeout(SetClockToTickEverySecond, delay);
      }

      function OpenForConnections() {
        peer = new Peer([ID], {});

        //Connection to server established - listening for lanes to connect
        peer.on("open", function (id) {
          console.log("Connected and listening");
          ID = id;
          document.getElementById("connection_status").innerText =
            "Waiting to for first lane to connect...";
        });

        //A lane has connected
        peer.on("connection", function (c) {
          console.log("Lane Connected");

          c.on("open", () => {
            let lane_number = c.peer.replace(
              PEER_BASE + "-" + LANE_TYPE + "-",
              ""
            );
            lane_number = parseInt(lane_number);

            if (_isLaneConnected(lane_number)) {
              c.send({ error: "That lane is taken" });
              c.close();
            } else {
              c.send({ connection_sucess: "Lane sucessfully added" });
              LANES[lane_number] = { connection: c };

              UpdateLaneConnections();
            }
          });

          c.on("close", () => {
            let lane_number = c.peer.replace(
              PEER_BASE + "-" + LANE_TYPE + "-",
              ""
            );
            lane_number = parseInt(lane_number);

            //lane disconnected, but don't delete, change it to disconnected

            LANES[lane_number].connection = undefined;

            UpdateLaneConnections();
          });
        });

        //Connection to server failed - try again
        peer.on("error", (err) => {
          console.log("ERROR CONNECTING. Retrying...");
          setTimeout(() => {
            OpenForConnections();
          }, 200);
        });
      }

      function _isLaneConnected(lane_number) {
        let buttons = document.getElementById("connections_screen");
        let found = false;
        Array.from(buttons.children).forEach((e) => {
          if (parseInt(e.innerText) == lane_number) {
            found = true;
          }
        });

        if (found) {
          return LANES[lane_number].connection != undefined;
        }
        return found;
      }

      function _getNewLaneButton(lane_number) {
        let lane_div = document.createElement("div");
        let lane_p = document.createElement("p");

        lane_p.innerText = lane_number;
        lane_p.classList.add("pfill");
        lane_div.appendChild(lane_p);
        lane_div.classList.add("connectedLane");
        lane_div.classList.add("lane");
        lane_div.id = "lane_" + lane_number;
        return lane_div;
      }
      function _getNewDisConnectedLaneButton(lane_number) {
        let lane_div = document.createElement("div");
        let lane_p = document.createElement("p");

        lane_p.innerText = lane_number;
        lane_p.classList.add("pfill");
        lane_div.appendChild(lane_p);
        lane_div.classList.add("disconnected");
        lane_div.classList.add("lane");
        lane_div.id = "lane_" + lane_number;
        return lane_div;
      }
      function UpdateLaneConnections() {
        let keys = Object.keys(LANES);
        let connections_screen = document.getElementById("connections_screen");
        while (connections_screen.firstChild) {
          connections_screen.removeChild(connections_screen.firstChild);
        }

        keys.forEach((key) => {
          let lane = key;
          let c = LANES[key].connection;

          if (c !== undefined) {
            connections_screen.appendChild(_getNewLaneButton(lane));
          } else {
            connections_screen.appendChild(_getNewDisConnectedLaneButton(lane));
          }
        });
      }
    </script>
  </body>
</html>
