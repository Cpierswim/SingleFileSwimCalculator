<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Coach Server</title>
    <link
      href="https://fonts.googleapis.com/css?family=Noto Sans Mono"
      rel="stylesheet"
    />
    <style>
      #Main_Clock {
        color: greenyellow;

        font-weight: 600;
        font-family: "Noto Sans Mono", "Courier New", Courier, monospace;
        width: 80vw;
      }

      #Coach_Controls {
        width: 20vw;
        border-left: 8px solid red;
      }

      #container {
        width: 100vw;
        height: 100vh;
        display: block;
      }

      .black_background {
        background-color: black;
      }

      #connections_screen {
        width: 100%;
      }

      #connection_status {
        font-size: large;
        color: white;
      }
      .pfill {
        margin: 0px;
        margin-top: -4px;
      }
      .lane {
        width: 50px;
        height: 50px;
        border-style: solid;
        border-width: 2px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 50px;
        font-weight: 800;
        font-family: "Bowlby One SC", cursive;
      }
      .connectedLane {
        border-color: aqua;
        background-color: aquamarine;
      }
      .disconnected {
        border-color: blueviolet;
        background-color: brown;
        color: beige;
      }
      #upper_div {
        width: 100%;
        height: 20%;
      }
      #lower_div {
        height: 80%;
        width: 100%;
        border-color: white;
        border-bottom: 3px;
        border-style: solid;
      }
      #room_code {
        float: left;
        width: 15%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5vw;
        color: white;
        font-weight: 600;
        text-align: center;
      }
      #clock_div {
        float: left;
        width: 45%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10vw;
        color: greenyellow;
        font-weight: 600;
        font-family: "Courier New", Courier, monospace;
      }
      #connections_div {
        float: left;
        width: 40%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
      }
    </style>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.2.0/dist/peerjs.min.js"></script>
  </head>
  <body>
    <div class="container" id="container">
      <button type="button" onclick="startApp()" id="fullscreenbutton">
        Cick Me To Start App
      </button>
    </div>

    <script>
      const PEER_BASE = "3SLDFGPSOGHAA";
      const PEER_TYPE = "COACH";
      const LANE_TYPE = "LANE";
      let ID = PEER_BASE + "-" + PEER_TYPE;
      let ROOM_CODE = "";
      const LANES = {};
      const SKIP_FULLSCREEN = 1;

      var clock;
      var time_delta;

      async function getTimeDelta() {
        const start_millis = Date.now();
        const response = await axios.get(
          `https://worldtimeapi.org/api/timezone/America/Detroit`
        );
        const end_millis = Date.now();
        const data = response.data;

        const trip_time = end_millis - start_millis;
        const server_millis = parseInt(
          data["unixtime"] +
            data["utc_datetime"].split(".")[1].split("+")[0].substring(0, 3)
        );

        time_delta = server_millis - start_millis - Math.floor(trip_time / 2);
      }

      function SetClock() {
        var start = Date.now() + time_delta;
        const date = new Date(start);
        var minutes = date.getMinutes();
        var seconds = date.getSeconds();
        const checkTime = (i) => {
          if (i < 10) return `0${i}`;
          return i + "";
        };
        const minute = checkTime(minutes);
        const second = checkTime(seconds);
        clock.innerText = `${minute}:${second}`;
      }

      function requestFullScreen(div_to_fullscreen) {
        //request Full Screen
        if (typeof SKIP_FULLSCREEN === "undefined") return;
        if (SKIP_FULLSCREEN == 1) return;

        if (div_to_fullscreen.requestFullscreen) {
          div_to_fullscreen.requestFullscreen();
        } else if (div_to_fullscreen.webkitRequestFullscreen) {
          /* Safari */
          div_to_fullscreen.webkitRequestFullscreen();
        } else if (div_to_fullscreen.msRequestFullscreen) {
          /* IE11 */
          div_to_fullscreen.msRequestFullscreen();
        }
      }

      async function startApp() {
        var main_screen = document.getElementById("container");
        main_screen.classList.add("black_background");
        requestFullScreen(main_screen);

        //Update the display to the clock - will need to refactor later
        const full_screen_button = document.getElementById("fullscreenbutton");
        full_screen_button.remove();

        const upper_div = document.createElement("div");
        upper_div.id = "upper_div";
        main_screen.appendChild(upper_div);

        const lower_div = document.createElement("div");
        lower_div.id = "lower_div";
        main_screen.appendChild(lower_div);

        const room_code_div = document.createElement("div");
        room_code_div.id = "room_code";
        upper_div.appendChild(room_code_div);
        const room_code_p = document.createElement("p");
        room_code_p.id = "room_code_text";
        room_code_p.innerHTML = "Room Code: <br />---";
        room_code_div.appendChild(room_code_p);

        const clock_div = document.createElement("div");
        clock_div.id = "clock_div";
        upper_div.appendChild(clock_div);
        const clock_p = document.createElement("p");
        clock_p.id = "clock_text";
        clock_p.innerHTML = "00:00";
        clock_div.appendChild(clock_p);
        const connections_div = document.createElement("div");
        connections_div.id = "connections_div";
        connections_div.innerText = "Connecting to server...";
        upper_div.appendChild(connections_div);

        clock = clock_p;

        //start the clock
        await getTimeDelta();
        StartClock();
        OpenForConnections();
      }

      function ResetClock() {
        SetClock();
      }

      function SetClockToTickEverySecond() {
        SetClock();
        setInterval(ResetClock, 1000);
      }

      async function StartClock() {
        SetClock();
        var start = Date.now() + time_delta;
        const date = new Date(start);
        var delay = 1000 - date.getMilliseconds();
        setTimeout(SetClockToTickEverySecond, delay);
      }

      function OpenForConnections() {
        peer = new Peer();

        //Connection to server established - listening for lanes to connect
        peer.on("open", async function (id) {
          console.log("Connected and listening");
          ID = id;
          let aws_result = await axios.post(
            "https://v0b4jr6h2k.execute-api.us-east-2.amazonaws.com/test/coach",
            {
              id: ID,
            },
            {
              headers: { "Content-Type": "text/plain" },
            }
          );

          ROOM_CODE = aws_result.data.body.key;

          document.getElementById("room_code_text").innerHTML =
            "Room Code:<br />" + ROOM_CODE;

          document.getElementById("connections_div").innerText =
            "Waiting to for first lane to connect...";
        });

        //A lane has connected
        peer.on("connection", function (c) {
          console.log("Lane Connected");

          c.on("open", () => {
            let lane_number = c.peer;
            let index = c.peer.indexOf("Lane-");
            index += "Lane-".length;
            lane_number = c.peer.substring(index, c.peer.length);
            lane_number = parseInt(lane_number);

            lane_number = _getLaneNumerFromLaneConnectionID(c.peer);

            if (_isLaneConnected(lane_number)) {
              c.send({ error: "That lane is taken" });
              c.close();
            } else {
              c.send({ connection_sucess: "Lane sucessfully added" });
              LANES[lane_number] = { connection: c };

              UpdateLaneConnections();
            }
          });

          c.on("close", () => {
            let lane_number = _getLaneNumerFromLaneConnectionID(c.peer);

            //lane disconnected, but don't delete, change it to disconnected

            LANES[lane_number].connection = undefined;

            UpdateLaneConnections();
          });
        });

        //Connection to server failed - try again
        peer.on("error", (err) => {
          console.log("ERROR CONNECTING. Retrying...");
          setTimeout(() => {
            OpenForConnections();
          }, 200);
        });
      }

      function _getLaneNumerFromLaneConnectionID(id) {
        let index = id.indexOf("Lane-");
        index += "Lane-".length;
        let lane_number = id.substring(index, id.length);
        lane_number = parseInt(lane_number);
        return lane_number;
      }

      function _isLaneConnected(lane_number) {
        let buttons = document.getElementById("connections_div");
        let found = false;
        Array.from(buttons.children).forEach((e) => {
          if (parseInt(e.innerText) == lane_number) {
            found = true;
          }
        });

        if (found) {
          return LANES[lane_number].connection != undefined;
        }
        return found;
      }

      function _getNewLaneButton(lane_number) {
        let lane_div = document.createElement("div");
        let lane_p = document.createElement("p");

        lane_p.innerText = lane_number;
        lane_p.classList.add("pfill");
        lane_div.appendChild(lane_p);
        lane_div.classList.add("connectedLane");
        lane_div.classList.add("lane");
        lane_div.id = "lane_" + lane_number;
        return lane_div;
      }
      function _getNewDisConnectedLaneButton(lane_number) {
        let lane_div = document.createElement("div");
        let lane_p = document.createElement("p");

        lane_p.innerText = lane_number;
        lane_p.classList.add("pfill");
        lane_div.appendChild(lane_p);
        lane_div.classList.add("disconnected");
        lane_div.classList.add("lane");
        lane_div.id = "lane_" + lane_number;
        return lane_div;
      }
      function UpdateLaneConnections() {
        let keys = Object.keys(LANES);
        let connections_screen = document.getElementById("connections_div");
        while (connections_screen.firstChild) {
          connections_screen.removeChild(connections_screen.firstChild);
        }

        keys.forEach((key) => {
          let lane = key;
          let c = LANES[key].connection;

          if (c !== undefined) {
            connections_screen.appendChild(_getNewLaneButton(lane));
          } else {
            connections_screen.appendChild(_getNewDisConnectedLaneButton(lane));
          }
        });
      }
    </script>
  </body>
</html>
